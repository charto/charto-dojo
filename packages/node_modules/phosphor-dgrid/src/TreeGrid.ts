// This file is part of phosphor-dgrid, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import 'dojo/resources/dnd.css';

import * as declare from 'dojo/_base/declare';
import * as Tree from 'dgrid/Tree';
import * as DnD from 'dgrid/extensions/DnD';
import * as Editor from 'dgrid/Editor';
import { BaseGrid, BaseGridOptions } from './BaseGrid';

import { getRoot, isProtected, protect, unprotect } from 'mobx-state-tree';
import { Mstore, MstoreNode } from 'mst-dstore';

import * as aspect from 'dojo/aspect';
import * as Source from 'dojo/dnd/Source';
import * as OnDemandGrid from 'dgrid/OnDemandGrid';
import * as Keyboard from 'dgrid/Keyboard';
import * as Selection from 'dgrid/Selection';
import * as ColumnResizer from 'dgrid/extensions/ColumnResizer';

let dndPatched = false;

export function patchDnD() {
	if(dndPatched) return;
	dndPatched = true;

	function nop() {}

	const gridSourceProto = (DnD.GridSource as any).prototype;

	// Prevent dojo/dnd from eating mousedown events
	// needed for updating keyboard focus in dgrid.
	
	aspect.before((Source as any).superclass, 'onMouseDown', (e: MouseEvent) => {
			e.stopPropagation = nop;
			e.preventDefault = nop;
			return([ e ]);
	});
	
	aspect.before(
		gridSourceProto,
		'onDrop',
		function(
			this: DnD.GridSource,
			sourceSource: DnD.GridSource,
			nodes: HTMLCollectionOf<HTMLElement>,
			copy: boolean
		) {
			const DnD: any = this;
	
			DnD.dropBefore = DnD.before;
			DnD.before = true;
		}
	);
	
	aspect.before(
		gridSourceProto,
		'onDropInternal',
		function(
			this: DnD.GridSource,
			nodes: HTMLCollectionOf<HTMLElement>,
			copy: boolean,
			targetItem: MstoreNode
		) {
			const DnD: any = this;
	
			DnD.before = DnD.dropBefore;
	
			return([ nodes, copy, { DnD: this, item: targetItem } ]);
		}
	);
}

export type TreeGridColumn = Tree.Column & Editor.Column;

export type TreeGridOptionsBase = (
	BaseGridOptions &
	Tree.KwArgs &
	Editor.KwArgs &
	DnD.KwArgs
);

export interface TreeGridOptions extends TreeGridOptionsBase {
	shouldExpand?: (row: any, level: number, expanded: boolean) => boolean;
	onShowEditor?: (element: HTMLElement, column: TreeGridColumn, cell: HTMLTableCellElement, value: any) => any;
	columns: TreeGridColumn[];
	mstore: Mstore
}

export interface HookableEditor extends Editor {
	_showEditor(element: HTMLElement, column: TreeGridColumn, cell: HTMLTableCellElement, value: any): void;
}

export class DojoTree extends declare([
	BaseGrid.GridClass,
	Tree,
	Editor as dgrid.Constructor<HookableEditor, Editor.KwArgs>,
	DnD
]) {

	constructor(options: TreeGridOptions, div?: HTMLDivElement) {
		super(options, div);

		patchDnD();

		this.onShowEditor = options.onShowEditor;
		this.mstore = options.mstore;
	}

	/** Ensure state tree is unprotected before saving changes. */

	save() {
		let wasProtected = false;
		const store = this.mstore;
		++store.busy;

		if(isProtected(store.treeRoot)) {
			unprotect(getRoot(store.treeRoot));
			wasProtected = true;
		}

		let result = super.save();

		if(wasProtected) {
			result = result.then((changed) => {
				protect(getRoot(store.treeRoot));
				return(changed);
			});
		}

		--store.busy;
		return(result);
	}

	/** Also track in state tree, whether branches are open. */

	expand(target: any, ...args: any[]) {
		const store = this.mstore;
		++store.busy;

		const result = super.expand(target, ...args);
		const row = target.element ? target : this.row(target);

		if((this as any)._expanded[row.id]) {
			row.data.expand();
		} else {
			row.data.collapse();
		}

		--store.busy;
		return(result);
	}

	renderRow(item: MstoreNode, options?: Object) {
		const row = super.renderRow(item, options);
		row.classList.add(!item.children ? 'grid-leaf' : 'grid-branch');

		return(row);
	}

	_showEditor(element: HTMLElement, column: TreeGridColumn, cell: HTMLTableCellElement, value: any) {
		super._showEditor(element, column, cell, value);
		if(this.onShowEditor) this.onShowEditor(element, column, cell, value);
	}

	onShowEditor?: (element: HTMLElement, column: TreeGridColumn, cell: HTMLTableCellElement, value: any) => any;

	mstore: Mstore;

}

export class TreeGrid extends BaseGrid {

	constructor(options: TreeGridOptions) {
		super(options, DojoTree);

		this.dgrid.set('collection', options.mstore.getRootCollection());
	}

	dgrid: DojoTree;

}
